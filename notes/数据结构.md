# 数据结构

## 数据结构分类

### 数组

> 用来存储多个数据的集合。一般在创建数组的时候，需要确定其最大容量。如果数据过大，只能扩容，较耗性能。数组相对于链表来说，取下标值的数据更快。但是插入和删除速度较慢，由于其在中间部位插入数据，后面数据需要逐个后移，留出一定空间才可以操作。

### 栈

> 栈是一种受限的线性表，**后进先出(LIFO)**。其限制只能在**栈的一端对栈进行插入，删除**。这一端称为`栈顶`，而末端称为`栈底`。

```ts
function Stack() {
  this.items = [];

  // 压栈
  Stack.prototype.push = function(element) {
    this.items.push(element);
  };

  // 从栈中取出
  Stack.prototype.pop = function() {
    return this.items.pop();
  };

  // 查看栈顶元素
  Stack.prototype.peek = function() {
    return this.items[this.items.length - 1];
  };

  // 判断栈是否为空
  Stack.prototype.isEmpty = function() {
    return this.items.length === 0;
  };

  // 获取栈中元素的个数
  Stack.prototype.size = function() {
    return this.items.length;
  };

  // toString方法
  Stack.prototype.toString = function() {
    var resultStr = "";
    for (let i = 0; i < this.items.length; i++) {
      resultStr += i;
    }
    return resultStr;
  };
}

const list = new Stack();
```

### 队列

> 队列是一种受限的线性表，**先进先出**。它只允许在**表的前端进行删除操作**，而在**表的后端进行插入操作**。

使用数组实现队列

```ts
function Queue() {
  this.items = [];
  // 将元素添加到队列中
  Queue.prototype.enqueue = function(element) {
    this.items.push(element);
  };

  // 从队列中删除元素
  Queue.prototype.dequeue = function() {
    return this.items.shift();
  };

  // 查看队列第一个的元素
  Queue.prototype.front = function() {
    return this.items[0];
  };

  // 查看队列是否为空
  Queue.prototype.isEmpty = function() {
    return this.items.length === 0;
  };

  // 查看队列中元素的个数
  Queue.prototype.size = function() {
    return this.items.length;
  };

  // toString方法
  Queue.prototype.toString = function() {
    var resultStr = "";
    for (let i = 0; i < this.items.length; i++) {
      resultStr += i;
    }
    return resultStr;
  };
}
```

#### 优先级队列

> 队列中出了`数据`，还包含其数据的`优先级`

```ts
function PriorityQueue() {
  this.items = [];

  // 内部类,数据项实例（数据项 = 数据 + 优先级）
  function PriorityElement(element, priority) {
    this.element = element;
    this.priority = priority;
  }

  PriorityQueue.prototype.enqueue = function(element, priority) {
    var tempElement = new PriorityElement(element, priority);

    if (!this.items.length) {
      this.items.push(tempElement);
    } else {
      for (let i = 0; i < this.items.length; i++) {
        if (tempElement.priority > this.items[i].priority) {
          this.items.splice(i, 0, tempElement); // 指定位置i处添加数据项
          return;
        }
      }
      this.items.push(tempElement); // 当前数据项优先级最低，直接末尾插入
    }
  };
}

var priorityQueue = new PriorityQueue();
priorityQueue.enqueue(1, 1);
priorityQueue.enqueue(3, 3);
priorityQueue.enqueue(2, 2);
console.log(priorityQueue);
```

### 链表

> 链表中的元素在内存中**不必是连续的空间**，链表的每一个元素都是由**一个存储元素本身的节点**和**指向下一个元素的引用**组成。相对于数组来说，链表的插入和删除操作速度更快，但在取下标值的数据时很慢，由于其要根据引用逐个进行查找。

```ts
function LinkedList() {
  function Node(data) {
    this.data = data;
    this.next = null;
  }
  // 链表属性
  this.head = null;
  this.length = 0;

  // 末尾添加元素
  LinkedList.prototype.append = function(data) {
    var newNode = new Node(data);

    if (this.length === 0) {
      this.head = newNode;
    } else {
      var current = this.head; // 从head开始，逐个查询其节点数据是否存在
      while (current.next) {
        current = current.next;
      }
      current.next = newNode;
    }
    this.length += 1;
  };

  // 转换为字符串
  LinkedList.prototype.toString = function() {
    var tempString = "";
    var current = this.head;
    while (current && current.data) {
      tempString += ` ${current.data} `;
      current = current.next || null;
    }
    return tempString;
  };

  // 插入元素
  LinkedList.prototype.insert = function(position, data) {
    var newNode = new Node(data);
    // 越界判断
    if (position < 0 || position > this.length) {
      throw new Error("Error: out of bounds");
      return;
    }

    if (position === 0) {
      newNode.next = this.head; // 将新数据项的指针，指向头部
      this.head = newNode; // 指定新数据项为头部
    } else {
      var previous = null;
      var current = this.head;
      var index = 0;

      while (index++ < position) {
        previous = current;
        current = current.next;
      }
      newNode.next = current;
      previous.next = newNode;
      this.length += 1;
    }
  };

  // 获取指定index的数据
  LinkedList.prototype.get = function(position) {
    // 越界判断
    if (position < 0 || position >= this.length) {
      throw new Error("Error: out of bounds");
      return;
    }
    let index = 0;
    let current = this.head;

    while (index++ < position) {
      current = current.next;
    }
    return current.data;
  };

  // 获取指定数据的下标
  LinkedList.prototype.indexOf = function(data) {
    var current = this.head;

    for (var i = 0; i < this.length; i++) {
      if (current.data === data) {
        return i;
      }
      current = current.next;
    }
    return -1;
  };

  // 修改指定位置元素
  LinkedList.prototype.update = function(position, data) {
    // 越界判断
    if (position < 0 || position >= this.length) {
      throw new Error("Error: out of bounds");
      return;
    }
    let index = 0;
    let current = this.head;

    while (index++ < position) {
      current = current.next;
    }
    current.data = data;
  };

  // 移除指定位置的元素
  LinkedList.prototype.removeAt = function(position) {
    // 越界判断
    if (position < 0 || position >= this.length) {
      throw new Error("Error: out of bounds");
      return;
    }

    var current = this.head;

    if (position === 0) {
      this.head = current.next;
    } else {
      var previous = null;
      var index = 0;

      while (index++ < position) {
        previous = current;
        current = current.next;
      }
      previous.next = current.next || null;
    }
    return current.data;
  };

  // 移除指定元素
  LinkedList.prototype.remove = function(data) {
    var position = this.indexOf(data);
    this.removeAt(position);
  };

  LinkedList.prototype.isEmpty = function() {
    return !!this.length;
  }

  LinkedList.prototype.size = function() {
    return this.length;
  }
}

var linkedList = new LinkedList();
linkedList.append("a");
linkedList.append("b");
linkedList.append("c");
linkedList.insert(1, "a++");
linkedList.update(0, "aaa");
// linkedList.removeAt(3)
linkedList.remove("b");
// linkedList.removeAt(linkedList.length -1)
// console.log(linkedList.indexOf('kerwin'))
// console.log(linkedList.get(1));
console.log(linkedList.toString());
```
