# 数据结构

## 数据结构分类

### 数组

### 栈
>栈是一种受限的线性表，**后进先出(LIFO)**。其限制只能在**栈的一端对栈进行插入，删除**。这一端称为`栈顶`，而末端称为`栈底`。
```ts
function Stack() {
  this.items = [];

  // 压栈
  Stack.prototype.push = function(element) {
    this.items.push(element);
  }

  // 从栈中取出
  Stack.prototype.pop = function() {
    return this.items.pop();
  }

  // 查看栈顶元素
  Stack.prototype.peek = function() {
    return this.items[this.items.length - 1];
  }

  // 判断栈是否为空
  Stack.prototype.isEmpty = function() {
    return this.items.length === 0;
  }

  // 获取栈中元素的个数
  Stack.prototype.size = function() {
    return this.items.length;
  }

  // toString方法
  Stack.prototype.toString = function() {
    var resultStr = '';
    for (let i = 0; i < this.items.length; i++) {
      resultStr += i;
    }
    return resultStr;
  }
}

const list = new Stack();
```

### 队列
>队列是一种受限的线性表，**先进先出**。它只允许在**表的前端进行删除操作**，而在**表的后端进行插入操作**。


使用数组实现队列
```ts
function Queue() {
  this.items = [];
  // 将元素添加到队列中
  Queue.prototype.enqueue = function(element) {
    this.items.push(element);
  }

  // 从队列中删除元素
  Queue.prototype.dequeue = function() {
    return this.items.shift();
  }

  // 查看队列第一个的元素
  Queue.prototype.front = function() {
    return this.items[0];
  }

  // 查看队列是否为空
  Queue.prototype.isEmpty = function() {
    return this.items.length === 0;
  }

  // 查看队列中元素的个数
  Queue.prototype.size = function() {
    return this.items.length;
  }

  // toString方法
  Queue.prototype.toString = function() {
    var resultStr = '';
    for (let i = 0; i < this.items.length; i++) {
      resultStr += i;
    }
    return resultStr;
  }
}
```

#### 优先级队列
>队列中出了`数据`，还包含其数据的`优先级`

```ts
function PriorityQueue() {
  this.items = [];

  // 内部类,数据项实例（数据项 = 数据 + 优先级）
  function PriorityElement(element, priority) {
    this.element = element;
    this.priority = priority;
  }

  PriorityQueue.prototype.enqueue = function(element, priority) {
    var tempElement = new PriorityElement(element, priority);

    if (!this.items.length) {
      this.items.push(tempElement);
    } else {
      for (let i = 0; i < this.items.length; i++) {
        if (tempElement.priority > this.items[i].priority) {
          this.items.splice(i, 0, tempElement); // 指定位置i处添加数据项
          return;
        }
      }
      this.items.push(tempElement); // 当前数据项优先级最低，直接末尾插入
    }
  }
}

var priorityQueue = new PriorityQueue();
priorityQueue.enqueue(1, 1)
priorityQueue.enqueue(3, 3)
priorityQueue.enqueue(2, 2)
console.log(priorityQueue)
```